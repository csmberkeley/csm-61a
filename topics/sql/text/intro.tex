SQL (Structured Query Language) is a declarative programming language that allows us to store, access, and manipulate data stored in databases.
Each database contains tables, which can store many rows of data that all share the same properties (columns). 


\subsection{Creating Tables}
\subsubsection{\lstinline{SELECT}}
\lstinline{SELECT} statements are used to create tables. The following creates a table with a single row: 
\begin{lstlisting}
sqlite> SELECT "Adit" AS first, "Balasubramanian" AS last;
Adit|Balasubramanian    
\end{lstlisting}

\lstinline{AS} is an ``aliasing'' operation that gives the columns of the table names. Note that built-in keywords such as \lstinline{AS} and \lstinline{SELECT} are capitalized by convention in SQL. However, SQL is case insensitive, so we could just as easily write \lstinline{as} and \lstinline{select}. Also, each SQL query must end with a semicolon. 

\subsubsection{\lstinline{UNION}}
\lstinline{UNION} joins together two tables with the same number of columns. The column names of the first table are kept. 

\begin{lstlisting}
sqlite> SELECT "Adit" AS first, "Balasubramanian" AS last UNION
...> SELECT "Gabe", "Classon";
Adit|Balasubramanian
Gabe|Classon
\end{lstlisting}

\subsubsection{\lstinline{CREATE TABLE}}
To create a named table (that can be used again), the \lstinline{CREATE TABLE} command is used: 
\begin{lstlisting}
sqlite> CREATE TABLE scms AS 
...> SELECT "Adit" AS first, "Balasubramanian" AS last UNION
...> SELECT "Gabe", "Classon";
Adit|Balasubramanian
Gabe|Classon
\end{lstlisting}

\begin{meta}
It is nice to note that SQL syntax is supposed to mirror English grammar closely so that it is natural to understand. 
\end{meta}

The remaining examples will use the following \lstinline{team} table: 
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|r|}
    \hline
    \textbf{name}  & \textbf{pet} & \textbf{birth\_month} \\ \hline
    Gabe   & cat  & 11                              \\ \hline
    Adit   & none  & 10                              \\ \hline
    Alyssa & dog   & 4                               \\ \hline
    Esther & dog   & 6                               \\ \hline
    Maya   & none   & 3                               \\ \hline
    Manas  & none   & 11                              \\ \hline
    \end{tabular}
    \end{table}
\subsection{Manipulating other tables}
We can also write \lstinline{SELECT} statements to create new tables from other tables. We write the columns we want after the \lstinline{SELECT} command and use a \lstinline{FROM} clause to designate the source table. For example, the following will create a new table containing only the \lstinline{name} and \lstinline{birth_month} columns of \lstinline{team}: 
\begin{lstlisting}
sqlite> SELECT name, birth_month FROM team; 
Gabe|11
...
Manas|11
\end{lstlisting}

An asterisk \lstinline{*} selects for all columns of the table: 
\begin{lstlisting}
sqlite> SELECT * FROM team; 
Gabe|cat|11
...
Manas|none|11
\end{lstlisting}

This is a convenient way to view all columns of a table. 

We may also manipulate the table columns and use \lstinline{AS} to provide a (new) name to the columns of the source table. The following query creates a table with each teammate's name and the number of months between their birth month and June: 
\begin{lstlisting}
sqlite> SELECT name, ABS(birth_month - 6) AS june_dist FROM team; 
Gabe|5
...
Manas|5
\end{lstlisting}

\subsubsection{\lstinline{WHERE}}
\lstinline{WHERE} allows us to filter rows based on certain criteria.  The \lstinline{WHERE} clause contains a boolean expression; only rows where that expression evaluates to true will be kept.  
\begin{lstlisting}
sqlite> SELECT name FROM team WHERE pet = "dog"; 
Alyssa
Esther
\end{lstlisting}

Note that \lstinline{=} in SQL is used for equality checking, not assignment. 

\subsubsection{\lstinline{ORDER BY}}
\lstinline{ORDER BY} specifies a value by which to order the rows of the new table. \lstinline{ORDER BY ...} may be followed by \lstinline{ASC} or \lstinline{DESC} to specify whether they should be ordered in ascending or descending order. \lstinline{ASC} is default. For strings, ascending order is alphabetical order.

\begin{lstlisting}
sqlite> SELECT name FROM team WHERE pet = "dog" ORDER BY name DESC; 
Esther
Alyssa
\end{lstlisting}

\subsection{Joins}
Sometimes, you need to compare values across two tables---or across two rows of the same table. Our current tools do not allow for this because they can only consider rows one-by-one. A way of solving this problem is to create a table where the rows consist of every possible combination of rows from the two tables; this is called an \textbf{inner join}. Then, we can filter through the combined rows to reveal relationships between rows. It sounds bizarre, but it works. 

An inner join is created by specifying multiple source tables in a \lstinline{WHERE} clause. For example, \lstinline{SELECT * FROM team AS a, team AS b;} will create a table with 36 rows and 6 columns. The table has 36 rows because each row represents one of 36 possible ways to select two rows from \lstinline{team} (where order matters). The table has 6 columns because the joined tables have 3 columns each. We use \lstinline{AS} to give the two source tables different names, since we are joining \lstinline{team} to itself. The columns of the resulting table are named \lstinline{a.name, a.pet, a.birth_month, b.name, b.pet, b.birth_month}. 

For example, to determine all pairs of people with the same birth month, we can use an inner join: 
\begin{lstlisting}
sqlite> SELECT * FROM team AS a, team AS b WHERE a.name < b.name AND a.birth_month = b.birth_month;
Gabe|Manas
\end{lstlisting}

\subsection{Aggregation}
Aggregation uses information from multiple rows in our table to create a single row. Using an aggregation function such as \lstinline{MAX}, \lstinline{MIN}, \lstinline{COUNT}, and \lstinline{SUM} will automatically aggregate the table data into a single row. For example, the following will collapse the entire table into one row containing the name of the person with the earliest birth month: 
\begin{lstlisting}
sqlite> SELECT name, MIN(birth_month) FROM team; 
Maya
\end{lstlisting}

The \lstinline{COUNT} aggregation function collapses the table into one row containing the number of rows in the table: 
\begin{lstlisting}
sqlite> SELECT COUNT(*) FROM team; 
6
\end{lstlisting}

\subsubsection{\lstinline{GROUP BY}}
\lstinline{GROUP BY} groups together all rows with the same value for a particular column. Aggregation is performed on each group instead of on the entire table. There is then exactly one row in the resulting table for each group. As before, type of aggregation performed is determined by the choice of aggregation function. The following gives the information of the person with the earliest birth month among all people with each type of pet: 
\begin{lstlisting}
sqlite> SELECT name, pet, MIN(birth_month) FROM team GROUP BY pet; 
Maya|none|3
Alyssa|dog|4
Gabe|cat|11
\end{lstlisting}

\subsubsection{\lstinline{HAVING}}
Just like \lstinline{WHERE} filters out rows, \lstinline{HAVING} filters out groups. For example, the following selects for all types of pets owned by more than one teammate: 
\begin{lstlisting}
sqlite> SELECT pet FROM team GROUP BY pet WHERE COUNT(*) > 1; 
none
dog
\end{lstlisting}

\subsection{Syntax}
The clauses of an SQL statement always come in this order: 
\begin{lstlisting}
SELECT ... FROM ... AS ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...;
\end{lstlisting}
The order roughly reflects the order in which the processing steps are applied. Note that all filtering of rows comes \textit{before} aggregation. That is, aggregation is always performed after the row-by-row filtering is complete. 

\begin{guide}
\begin{blocksection}
\textbf{Teaching Tips}
\begin{itemize}
    \item \lstinline{code.cs61a.org} has an interactive SQL terminal that lets you see visually the rows you extract from a given query.
    % \item To help understand aggregation, presenting a simple example of why this may be useful can help. For example, take a table where each row is the result of a game,
    % where it's a 1 if team A won and a 0 if team B won. Then, aggregation can be used to pick, for example,
    % all teams with at least 7 wins.
\end{itemize}
\end{blocksection}
\end{guide}
\begin{blocksection}
\question Implement \lstinline$compound$, which takes in a single-argument function \lstinline$base_func$ and returns a two-argument compounder function \lstinline$g$. The function \lstinline$g$ takes in an integer \lstinline$x$ and positive integer \lstinline$n$.

Each call to g will print the result of calling f repeatedly 1,2,...n times on x. That is, g(x, 2) prints f(x), then f(f(x)). Then, g will return the next two-argument compounder function.

This means that calling g(x, 2) will print f(f(f(x))), then f(f(f(f(x)))) and returns the next compounder function.

\begin{lstlisting}
def compound(base_func, prev_compound=None):
    """
    >>> add_one = lambda x: x + 1
    >>> adder = compound(adder)
    >>> adder = adder(3, 2)
    4       # f(x) = 4 + 1
    5       # f(f(x)) = 4 + 1 + 1
    >>> adder = adder(4, 4)
    6       # f(f(f(x)))
    7       # f(f(f(f(x))))
    8       # f(f(f(f(f(x)))))
    9       # f(f(f(f(f(f(x))))))
    """
    def g(x, n):
        if _____________________:
            new_comp = base_func
        else:
            new_comp = prev_compound
            while _____:
                print(___________)
                new_comp = (lambda a: lambda x:_______)(_____)
                n -= 1
        return compound(_________, ________)
    return g





\end{lstlisting}

\begin{solution}[1in]
\begin{lstlisting}
def compound(base_func, prev_compound=None):
  def g(x, n):
    if prev_compound is None:
      new_comp = base_func
    else:
      new_comp = prev_compound
      while n > 0:
        print(new_comp(x))
        new_comp = (lambda a: lambda x: base_func(a(x)))(new_comp)
        n -= 1
    return compound(base_func, new_comp)
  return g

\end{lstlisting}
\end{solution}
\end{blocksection}
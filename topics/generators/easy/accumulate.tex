\begin{blocksection}
\question Write a generator function that takes in an iterator \lstinline{it} and yields the running total of the elements produced by \lstinline{it}. 

\begin{lstlisting}
def accumulate(it):
    """
    >>> def all_ints():
    ...     i = 0
    ...     while True:
    ...         yield i
    ...         i += 1
    >>> a = accumulate(all_ints())
    >>> [next(a) for x in range(6)]
    [0, 1, 3, 6, 10, 15]
    """
\end{lstlisting}

\begin{solution}[2in]
\begin{lstlisting}
def accumulate(it):
    sum = 0
    while True:
        sum += next(it)
        yield sum
\end{lstlisting}
\end{solution}
\end{blocksection}

\begin{questionmeta}
This problem is meant to be a relatively simple introduction to the manipulation of iterators, generator function syntax, and how to deal with infinite generators. 

The doc test for this question is deliberately a bit complicated. It actually serves as a bit of a hint for how we might construct an infinite generator if one is provided to us (using an infinite loop). If students are concerned about this possibly erroring, remind them that generators only execute the body of the function when we tell them to, so this will not actually cause an infinite loop that hogs all of our computer's resources, causing a crash. 

Students have a tendency to want to do everything in generators with lists, which requires the computation of all elements of the generator at the same time; we need to encourage them to do ``lazy'' iteration, which means that each element is only computed when it's needed. Lazy iteration is a core concept of the topic; not only is it more efficient to do things this way, it's literally the only way to handle infinite iterators (whose elements cannot all be computed at the same time). Whenever I do iteration problems with my students, I ask them to consider what would happen if we provided them an infinite generator; if their implementation breaks, then it's not correct. 
\end{questionmeta}
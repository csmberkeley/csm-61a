\question
Write a generator function \lstinline{in_order} that takes in a possibly nested list of integers \lstinline{lst} and yields its integer elements in ascending order as a single non-nested list. You may find the built-in \lstinline{sorted} function useful, which takes in a list of \textit{integers} and returns a sorted list.

\begin{lstlisting}
def in_order(lst):
    """
    >>> l1 = [[3, 4, 2], [1, 7, 4]]
    >>> list(in_order(l1))
    [1, 2, 3, 4, 4, 7]
    >>> l2 = [2, [3], [1, [8], 4]]
    >>> list(in_order(l2))
    [1, 2, 3, 4, 8]
    """
    order = []

    for __________________________:

        if ____________________________:

            ___________________________________
        else:

            ___________________________________

    ____________________________________
\end{lstlisting}

\begin{solution}
\begin{lstlisting}
def in_order(lst):
    order = []
    for elem in lst:
        if isinstance(elem, list):
            order.extend(list(in_order(elem)))
        else:
            order.append(elem)
    yield from sorted(order)
\end{lstlisting}
\end{solution}

\begin{guide}
\begin{blocksection}
\textbf{Teaching Tips}
    \begin{itemize}
    \item Since we have nested lists, which can go on to be nested many times, it can be pretty difficult to manually go through each list and sort it. This gives the idea of using recursion.
    \item How can we make it so that we get a list of all of the elements (un-nested from their lists), and then call sorted to yield from a sorted list?
    \item Go over the isinstance method with a few examples, and see how it can be used to unflatten the given list (students went over a similar problem in lab)
    \item If the element we're checking is a list, then what do we do? If it's not then what do we do?
    \end{itemize}
\end{blocksection}
\end{guide}
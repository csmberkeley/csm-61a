\textbf{Representation Overview: \lstinline{__repr__} and \lstinline{__str__}}

\\
\\Classes can have "magic methods" that add special built-in syntax features. They start and end with double underscores, such as in \lstinline{__init__}.

The goal of \lstinline{__str__} is to convert an object to a human-readable string. The \lstinline{__str__} function is helpful for printing objects and giving us information that's more readable than \lstinline{__repr__}. Whenever we call \lstinline{print()} on an object, it will call the \lstinline{__str__} method of that object and print whatever value the \lstinline{__str__} call returned. However, if a class only defines \lstinline{__repr__} but not \lstinline{__str__}, the \lstinline{print()} call on an object will print what \lstinline{__repr__} returns instead. For example, if we had a \lstinline{Person} class with a name instance variable, we can create a \lstinline{__str__} method like this:
\begin{lstlisting}
def __str__(self):
    return "Hello, my name is " + self.name
\end{lstlisting}
This \lstinline{__str__} method gives us readable information: the person's name. Now, when we call print on a person, the following will happen:
\begin{lstlisting}
>>> p = Person("John Denero")
>>> str(p)
'Hello, my name is John Denero'
>>> print(p)              
Hello, my name is John Denero
\end{lstlisting}

The \lstinline{__repr__} magic method returns the "official" string representation of an object. You can invoke it directly by calling \lstinline{repr(<some object>)}. However, \lstinline{__repr__} doesn't always return something that is easily readable, that is what \lstinline{__str__} is for. Rather, \lstinline{__repr__} ensures that all information about the object is present in the representation. Specifically, by convention, this should look like a valid Python expression that could be used to recreate an object with the same value. When you ask Python to represent an object in the Python interpreter, it will automatically call \lstinline{repr} on that object and then print out the string that \lstinline{repr} returns. If we were to continue our \lstinline{Person} example from above, let's say that we added a \lstinline{repr} method:

\begin{lstlisting}
def __repr__(self):
    return f"Person({self.name})" 
    # Note that this returns a string that is exactly the
    # same as the expression we use to construct this object.
\end{lstlisting}

Then we can write the following code:

\begin{lstlisting}
# Python calls this object's repr function to see what
# to print on the line. Note, Python prints whatever 
# result it gets from repr so it removes the quotes
# from the string.
>>> p 
Person("John Denero")

# User is invoking the repr function directly.
# Since the function returns a string, its output
# has quotes. In the previous line, Python called
# repr and then printed the value. This line works 
# like a regular function call: if a function 
# returns a string, output that string with quotes.
>>> repr(p) 
'Person("John Denero")'
\end{lstlisting}



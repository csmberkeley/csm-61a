\textbf{Object oriented programming} is a programming paradigm that organizes relationships within data into \textbf{objects} and \textbf{classes}. In object oriented programming, each object is an \textbf{instance} of some particular class. For example, we can write a \lstinline{Car} class that acts as a template for cars in general: 

\begin{lstlisting}
class Car:
    wheels = 4
    def __init__(self):
        self.gas = 100

    def drive(self):
        self.gas -= 10
        print("Current gas level:", self.gas)

my_car = Car()
\end{lstlisting}

To represent an individual car, we can then initialize a new instance of \lstinline{Car} as \lstinline{my_car} by ``calling'' the class. Doing so will automatically construct a new object of type \lstinline{Car}, pass it into the \lstinline{__init__} method (also called the \textbf{constructor}), and then return it. Often, the \lstinline{__init__} method will initialize an object's \textbf{instance attributes}, variables specific to one object instead of all objects in its class. In this case, the \lstinline{__init__} method initially sets the \lstinline{gas} instance attribute of each car to 100. 
It is important to note, however, that you can also manually set object-specific attributes outside of the \lstinline{__init__} method through variable declaration and methods.

Classes can also have \textbf{class attributes}, which are variables shared by all instances of a class. In the above example, \lstinline{wheels} is shared by all instances of the \lstinline{Car} class. In other words, all cars have 4 wheels. 

Functions within classes are known as methods. \textbf{Instance methods} are special functions that act on the instances of a class. We've already seen the \lstinline{__init__} method. We can call instance methods by using the dot notation we use for instance attributes: 
\begin{lstlisting}
>>> my_car.drive()
Current gas level: 90
\end{lstlisting}
In instance methods, \lstinline{self} is the instance from which the method was called.  We donâ€™t have to explicitly pass in \lstinline{self} because, when we call an instance method from an instance, the instance is automatically passed into the first parameter of the method by Python. That is, \lstinline{my_car.drive()} is exactly equivalent to the following: 
\begin{lstlisting}
>>> Car.drive(my_car)
Current gas level: 80
\end{lstlisting}

\begin{meta}
Something I like to emphasize with my students is that you can \textit{only} access class and instance attributes using dot notation from an instance. That is, you can never just write \lstinline{__init__} or \lstinline{wheels}; you \textit{must} use dot notation to access these attributes. The reason that students are confused by this is that the rules of variable scope in classes are different from those in functions. They often feel like because they are ``inside'' the class they should be able to access all of these variables without dot notation. I think it's often useful to dispel this notion by emphasizing that the rules are different and that it's essentially the objects and classes that ``hold on'' to their instance variables. But you should be careful when giving an explanation like this to not confuse your students more. 

This overview is not meant to be a first exposure resource for your students, since there are so many ins and outs of OOP. It is likely that you will need to walk through some of the concepts in a more intuitive way than they are presented here. 
\end{meta}

An order of growth (OOG) characterizes the runtime \textbf{efficiency} of a program as its input becomes extremely large. Since we care about rate of growth, we ignore constant coefficients and exclusively consider the fastest growing term. For example, on very large inputs, $2n^2 + 3n - 20$ behaves the same as $n^2$. Common runtimes, in increasing order of time, are: constant, logarithmic, linear, quadratic, and exponential.

\textbf{Examples:}

Constant time means that no matter the size of the input, the runtime of your program is consistent. In the function \lstinline{f} below, no matter what you pass in for \lstinline{n}, the runtime is the same. \\
\begin{lstlisting}
def f(n):
   return 1 + 2
\end{lstlisting}
A common example of a linear OOG involves a single for/while loop. In the example below, as \lstinline{n} gets larger, the amount of time to run the function grows proportionally. \\
\begin{lstlisting}
def f(n):
   while n > 0:
      print(n)
      n -= 1
\end{lstlisting}
\newpage
We can modify this while loop to get an example of logarithmic OOG. Suppose that, instead of subtracting 1 each time, we halve the size of \lstinline{n}. For \lstinline{n = 1000}, the program would take 10 iterations to terminate (since $2^10 = 1024$). The runtime is propotional to $\log($\lstinline{n}$)$.
\begin{lstlisting}
def f(n):
   while n > 0:
      print(n)
      n /= 2
\end{lstlisting}
An example of a quadratic runtime involves nested for loops. If you increment the value of \lstinline{n} by only 1, an additional \lstinline{n} amount of work is being done, since the inner for loop will run one more time. This means that the runtime is proportional to \lstinline{n}$^{2}$. \\
\begin{lstlisting}
def f(n):
   for i in range(n):
      for j in range(n):
         print(i*j)
\end{lstlisting}

\begin{guide}
   \textbf{Teaching Tips}
   \begin{itemize}
      \item Try visualizing how orders of growth works for each orders of growth.
      \begin{itemize}
      \item You can walk through each of the examples above and tally up the amount of times the program runs. 
      \item For example, in the second f(n), we would jot down thefor f(6):
      \begin{itemize}
         \item Before while: n = 6. Runs: 0.
         \item During first iteration: n = 5. Runs: 1.
         \item During second iteration: n = 4. Runs: 2.
         \item During third iteration: n = 3. Runs: 3.
         \item During fourth iteration: n = 2. Runs: 4.
         \item During fifth iteration: n = 1. Runs: 5.
         \item During sixth iteration: n = 0. Runs: 6.
      \end{itemize}
      \item So, from that visualization, we can see that this program seems to run in linear time. 
      \end{itemize}
   \end{itemize}
\end{guide}
\begin{blocksection}
\question Draw the environment diagram that results from running the following code.
\begin{lstlisting}
ghost = [1, 0,[3], 1]
def boo(spooky):
  ghost.append(spooky.append(ghost))
  spooky = spooky[ghost[2][1][1]]
  ghost[:].extend([spooky])
  spooky = [spooky] + [ghost[spooky - 1].pop()] 
  ghost.remove(ghost.remove(1))
  spooky += ["Happy Halloween!"]
  return spooky
pumpkin = boo(ghost[2])
\end{lstlisting}

\begin{solution}[1in]
  \url{http://go.addcnin.blue/csm-spookylist} \\
  Explanations for some tricky steps:
  \begin{itemize}
    \item Line 3: \lstinline{append} returns \lstinline{None}, so \lstinline{ghost} is appended to \lstinline{spooky} and \lstinline{None} is appended to \lstinline{ghost}
    \item Line 5: This does nothing because the value of this expression is never assigned to a variable. List slicing creates a copy of a list that is immediately deleted
    \item Line 6: Pop returns the last element of the original value of spooky. Since we use \lstinline{=} and then \lstinline{+} instead of \lstinline{+=}, a new list is created
    \item Line 7: \lstinline{remove} deletes the first element with a given value, so the first instance of 1 is deleted. \lstinline{remove} returns \lstinline{None}, so the outer call to \lstinline{remove} gets rid of the \lstinline{None} element of \lstinline{ghost}
    \item Line 8: \lstinline{+=} mutates \lstinline{spooky} instead of creating a new list 

  \end{itemize}
\end{solution}
\end{blocksection}
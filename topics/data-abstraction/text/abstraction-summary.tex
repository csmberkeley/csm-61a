Data abstraction allows us to create and access data through a controlled, restricted programming interface---hiding implementation details for sake of brevity and reusability of code and encouraging programmers to focus on how data is used rather than worrying about how data is internally organized. The two fundamental components of an \textbf{abstract data type} are a constructor and selectors:
\begin{enumerate}
	\item A \textbf{constructor} creates a piece of data, and includes all the attributes that make the data unique; e.g. executing \texttt{c = car("Nissan", "Leaf")} creates a new instance of a car abstraction and assigns it to the variable \lstinline{c}.
	\item \textbf{Selectors} access attributes of a piece of data; e.g. calling \lstinline{get_make(c)} returns \lstinline{"Nissan"}.
\end{enumerate}

In the example above, you don't know specifically how the model name ``Nissan'' and the make name ``Leaf'' are internally bundled into a car, and you don't care, either. The creator of the abstract data type dealt with those details, so that you, the user of the ADT, would only have to know how to store and retrieve the data you need. This separation of concerns between designing and using an interface is called the \textbf{abstraction barrier}. While your program won't necessarily break if you break the abstraction barrier, heeding the barrier is best practice and can prevent errors down the road. 

Using abstraction to hide unnecessary details can be seen everywhere, not just in code---keyboards, printers, cars, stovetops, and typewriters all employ abstractive interfaces. What are some examples of abstraction in your everyday life? 
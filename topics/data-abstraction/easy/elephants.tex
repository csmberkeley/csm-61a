\begin{blocksection}
\question The following is an \textbf{Abstract Data Type (ADT)} for elephants.
Each elephant keeps track of its name, age, and whether or not it can fly. Given
our provided constructor, fill out the selectors:

\begin{lstlisting}
def elephant(name, age, can_fly):
    """
    Takes in a string name, an int age, and a boolean can_fly.
    Constructs an elephant with these attributes.
    >>> dumbo = elephant("Dumbo", 10, True)
    >>> elephant_name(dumbo)
    "Dumbo"
    >>> elephant_age(dumbo)
    10
    >>> elephant_can_fly(dumbo)
    True
    """
    return [name, age, can_fly]

\end{lstlisting}

\end{blocksection}
\begin{blocksection}

\begin{lstlisting}
def elephant_name(e):
\end{lstlisting}
\begin{solution}[1in]
\begin{lstlisting}
    return e[0]
\end{lstlisting}
\end{solution}
\end{blocksection}
\begin{blocksection}

\begin{lstlisting}
def elephant_age(e):
\end{lstlisting}
\begin{solution}[1in]
\begin{lstlisting}
    return e[1]
\end{lstlisting}
\end{solution}
\end{blocksection}
\begin{blocksection}

\begin{lstlisting}
def elephant_can_fly(e):
\end{lstlisting}
\begin{solution}[1in]
\begin{lstlisting}
    return e[2]
\end{lstlisting}
\end{solution}
\end{blocksection}

%%% Question %%%

\begin{blocksection}
\question This function returns the correct result, but there's something wrong
about its implementation. How do we fix it?

\begin{lstlisting}
def elephant_roster(elephants):
    """
    Takes in a list of elephants and returns a list of their names.
    """
    return [elephant[0] for elephant in elephants]
\end{lstlisting}
\begin{solution}[1in]
\lstinline{elephant[0]} is a Data Abstraction Violation (DAV).
We should use a selector instead.
The corrected function looks like:
\begin{lstlisting}
def elephant_roster(elephants):
	return [elephant_name(elephant) for elephant in elephants]
\end{lstlisting}
\end{solution}

\end{blocksection}

%%% Question %%%

\begin{blocksection}
\question Fill out the following constructor for the given selectors.

\begin{lstlisting}
def elephant(name, age, can_fly):
\end{lstlisting}
\begin{solution}[1in]
\begin{lstlisting}
    return [[name, age], can_fly]
\end{lstlisting}
\end{solution}

\begin{lstlisting}
def elephant_name(e):
    return e[0][0]
\end{lstlisting}

\begin{lstlisting}
def elephant_age(e):
    return e[0][1]
\end{lstlisting}

\begin{lstlisting}
def elephant_can_fly(e):
    return e[1]
\end{lstlisting}

\end{blocksection}

%%% Question %%%

\begin{blocksection}
\question How can we write the fixed \texttt{elephant\char`_roster} function for
the constructors and selectors in the previous question?

\begin{solution}[1.5in]
No change is necessary to fix \texttt{elephant\char`_roster} since using the
\texttt{elephant} selectors ``protects'' the roster from constructor definition
changes.
\end{solution}

\end{blocksection}

\begin{blocksection}
\question \textbf{(Optional)} Fill out the following constructor for the given
selectors.

\begin{lstlisting}
def elephant(name, age, can_fly):
    """
    >>> chris = elephant("Chris Martin", 38, False)
    >>> elephant_name(chris)
        "Chris Martin"
    >>> elephant_age(chris)
        38
    >>> elephant_can_fly(chris)
        False
    """
    def select(command)
\end{lstlisting}
\begin{solution}[2in]
\begin{lstlisting}
        if command == "name":
            return name
        elif command == "age":
            return age
        elif command == "can_fly":
            return can_fly
        return "Breaking abstraction barrier!"
\end{lstlisting}
\end{solution}

\begin{lstlisting}
    return select
\end{lstlisting}

\begin{lstlisting}
def elephant_name(e):
    return e("name")
\end{lstlisting}

\begin{lstlisting}
def elephant_age(e):
    return e("age")
\end{lstlisting}

\begin{lstlisting}
def elephant_can_fly(e):
    return e("can_fly")
\end{lstlisting}

\end{blocksection}
\begin{blocksection}
\question What will Scheme output?

\begin{lstlisting}
scm> (if 1 1 (/ 1 0))
\end{lstlisting}
\begin{solution}[0.25in]
\begin{lstlisting}
1
\end{lstlisting}
If statements in Scheme have the form (if cond true-result false-result). Since 1 is a truthy value, we return the second argument, 1, and never evaluate the third argument due to short circuiting.
\end{solution}

\begin{lstlisting}
scm> (if 0 (/ 1 0) 1)
\end{lstlisting}
\begin{solution}[0.25in]
\begin{lstlisting}
Error: Zero Division
\end{lstlisting}
Recall that 0 is a Truth-y value in Scheme. Thus (/ 1 0) evaluates to a Zero Division Error
\end{solution}

\begin{lstlisting}
scm> (and 1 #f (/ 1 0))
\end{lstlisting}
\begin{solution}[0.25in]
\begin{lstlisting}
#f
\end{lstlisting}
And statements return the first falsey value it encounters. In this case, the second argument is \#f, so it returns that and never reaches the third argument.
\end{solution}

\begin{lstlisting}
scm> (and 1 2 3)
\end{lstlisting}
\begin{solution}[0.25in]
\begin{lstlisting}
3
\end{lstlisting}
Short-circuiting rules apply. This means that and returns the first False-y value or the last Truth-y value. In this case, the last Truth-y value is 3.
\end{solution}

\begin{lstlisting}
scm> (or #f #f 0 #f (/ 1 0))
\end{lstlisting}
\begin{solution}[0.25in]
\begin{lstlisting}
0
\end{lstlisting}
On the other hand, or statements return the first truthy value it encounters. In this case, that is the third argument, 0, and does not evaluate anything after.
\end{solution}
\end{blocksection}
\begin{blocksection}
\begin{lstlisting}
scm> (and (and) (or))
\end{lstlisting}
\begin{solution}[0.25in]
\begin{lstlisting}
#f
\end{lstlisting}
The special form or without any arguments evaluates to \#f. The special form and without any arguments evaluates to \#t. Also, short-circuiting rules apply. This means that and returns the first False-y value or the last Truth-y value. In this case, the first False-y value is \#f. 
\end{solution}

\begin{lstlisting}
scm> (define a 4)
\end{lstlisting}
\begin{solution}[0.25in]
\begin{lstlisting}
a
\end{lstlisting}
The define statement in Scheme always returns the name of the variable defined, in this case, a.
\end{solution}

\begin{lstlisting}
scm> ((lambda (x y) (+ a x y)) 1 2)
\end{lstlisting}
\begin{solution}[0.25in]
\begin{lstlisting}
7
\end{lstlisting}
We make a new lambda that takes in two arguments, x and y. The set of parentheses around the lambda evaluates it with the arguments 1 and 2, so we evaluate the body of the lambda with arguments 1 and 2, which adds them together.
\end{solution}

\begin{lstlisting}
scm> ((lambda (x y z) (y x z)) 2 / 2)
\end{lstlisting}
\begin{solution}[0.25in]
\begin{lstlisting}
1
\end{lstlisting}
We make a new lambda that takes in three arguments, x, y and z. The set of parentheses around the lambda evaluates it with the arguments 2, / and 2 respectively, so we evaluate the body of the lambda with x as 2, y as /, and z as 2. The body of the lambda is equivalent to (/ 2 2), and that’s what gets evaluated and returned.
\end{solution}
\end{blocksection}
\begin{blocksection}
\begin{lstlisting}
scm> ((lambda (x) (x x)) (lambda (y) 4))
\end{lstlisting}
\begin{solution}[0.25in]
\begin{lstlisting}
4
\end{lstlisting}
We make a new lambda that takes in one argument x. The set of parentheses around the lambda evaluates it with an argument of another lambda function, so we run the body (x x) with x as the (lambda (y) 4). Recall that evaluating an operator happens by putting parentheses around the operator and passing in an operand. When we do (x x), we’re evaluating the operator x with the parameter x. Therefore we’re now doing (lambda (y) 4) evaluated with the argument y as (lambda (y) 4). Since we evaluate the lambda, we evaluate the body and return it, which is 4. 
\end{solution}
\end{blocksection}

\begin{blocksection}
\question \begin{parts}
\part Define \lstinline$append$. In Scheme, \lstinline$append$ takes in two lists and
returns a larger list.

\begin{lstlisting}
> (append '(1 2 3) '(4 5 6))
(1 2 3 4 5 6)
\end{lstlisting}

\begin{solution}[0.5in]
\begin{lstlisting}
(define (append lst1 lst2)
    (if (null? lst1) lst2        
        (cons (car lst1) (append (cdr lst1) lst2)))))
\end{lstlisting}
\end{solution}

\part Define \lstinline$reverse$. Hint: use \lstinline$append$.

\begin{lstlisting}
> (reverse '(1 2 3))
(3 2 1)
\end{lstlisting}

\begin{solution}[1in]
\begin{lstlisting}
(define (reverse lst)
    (if (null? lst) lst
        (append (reverse (cdr lst)) (list (car lst)))))
\end{lstlisting}
\end{solution}

\part Define \lstinline$reverse$ tail-recursively. Hint: use a helper function and
\lstinline$cons$.

\begin{solution}[1in]
\begin{lstlisting}
(define (reverse lst)
    (define (helper lst reversed)
        (if (null? lst) reversed
            (helper (cdr lst) (cons (car lst) reversed ))))
    (helper lst '()))
\end{lstlisting}
\end{solution}
\end{parts}
\end{blocksection}

\begin{blocksection}
	\begin{guide}
	\textbf{Teaching Tips}
	\begin{enumerate}
			\item Board tip: this question requires creating several frames so save enough room on the board to draw this one out 
            \item The difficult part here is the fact that slicing or concatenating a list makes a new list. This is a good time to go over shallow copies.
            \item Talk about the recursive leap of faith for this problem since it shows how it works!
            \item To check students’ understanding it’s good to check whether the list returned is the same original object as the list passed in. i.e. why doesn’t lst change after calling reverse on it?
	\end{enumerate}
	\end{guide}
\end{blocksection}
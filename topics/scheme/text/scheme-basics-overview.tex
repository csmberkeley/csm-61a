Scheme is a \textit{functional} language, as opposed to Python, which is an \textit{imperative} language. A Python program is comprised of \textit{statements} or "instructions" which do not evaluate to a value (an example of a statement would be something like \lstinline{x = 3} in Python. This does not evaluate to any value but just instructs Python to create a variable \lstinline{x} with the value 3), whereas a Scheme program is comprised solely of \textit{expressions}, each of which simply evaluates to a value. Remember that the term evaluate means to find the value of something. A variable is evaluated by looking up the name in the current frame, and a function call expression is evaluated using the three steps listed below. The thing to notice is that different types of expressions have different rules for how to evaluate those expressions, and this goes for both Python and Scheme. 

The three basic types of expressions in Scheme are atomics/primitive expressions (i.e., a value itself, or, any self-evaluating expression), call expressions (procedure calls), and special forms (language features).  A call expression or special form is denoted by a pair of parentheses and takes prefix notation, i.e., it is formed as so:
\vspace{0.5mm}
\begin{lstlisting}
(operator operand_0, operand_1, ... , operand_n)
\end{lstlisting}

(Keep in mind each item in a call expression is also an expression)

Evaluation of a call expression progresses so:
\begin{enumerate}
\item Evaluate operator (returning a procedure)
\item Evaluate operands
\item Apply operator on operands
\end{enumerate}

\newpage 

\textbf{If Expression: }
The \lstinline{if} keyword is similar to \lstinline{if}/\lstinline{else} statements in Python. It works as follows:
\begin{lstlisting}
(if <predicate> <do if true> <do if false>)
\end{lstlisting}

This is similar to the following code in Python:
\begin{lstlisting}
if <predicate>:
    <do if true>
else:
    <do if false>
\end{lstlisting}

Note that in Python, \lstinline{if} is a statement whereas in Scheme, \lstinline{if} is an expression and evaluates to a value like any other expression would. This means that in Scheme you could write something like this where the \lstinline{if} expression can be placed as an operand in a function call expression:
\begin{lstlisting}
scm> (+ 1 (if #t 9 99))
10
\end{lstlisting}

Just like in Python, the \lstinline{<do if false>} (in Python this would be the equivalent to the else clause) is optional. If there is no \lstinline{<do if false>} and the \lstinline{<predicate>} evaluates to false then the \lstinline{if} expression evaluates to \lstinline{undefined}.
To create multi-conditional statements, you can nest if calls. For example, here is an example of a nested if-statement in Scheme:
\begin{lstlisting}
(if <predicate> <do if true> (if <predicate2> <do if true2> <do if both false>))
\end{lstlisting}

The Python equivalent would be:
\begin{lstlisting}
if <predicate>:
    <do if true>
elif <predicate2>:
    <do if true2>
else:
    <do if both false>
\end{lstlisting}

While this works, your code can become incredibly messy and hard to keep track of. A more efficient way of creating multi-conditional statements is through use of the \textit{cond} special form.
The preceding code can become more effectively accomplished through:
\begin{lstlisting}
(cond
    ((predicate) (do if predicate is true))
    ((predicate2) (do if predicate2 is true))
    (else (do if both predicates are false)))
\end{lstlisting}

Ultimately, it's your choice which special form to use in such cases: the nested if special forms may be more intuitive, while the cond special form may be more organized. Both accomplish the same general purpose.

\vspace{4mm}

\textbf{Define Expression: }
\lstinline{define} does two things in Scheme. The first is that it defines variables using the following syntax:
\begin{lstlisting}
(define <name> <expression>)
\end{lstlisting}

The way this works is Schme will evaluates \lstinline{<expression>} and binds the value to \lstinline{<name>} in the current environment. \lstinline{<name>} must be a valid Scheme symbol (you can think of a symbol as an identifier or variable name).

\lstinline{define} is also used to define functions using the following syntax (note that this is different from using \lstinline{define} to create variables as there is an extra pair of parentheses around \lstinline{<name> [param] ...}):
\begin{lstlisting}
(define (<name> [param] ...) <body> ...)
\end{lstlisting}

Either way, after the \lstinline{<name>} is bound to either a function or value, the define expression evaluates to the symbol \lstinline{<name>}.
\begin{lstlisting}
scm> (define x 3)
x
\end{lstlisting}

\url{https://cs61a.org/articles/scheme-spec/} will direct you to a page with all of the explanations and syntax descriptions of Scheme. Use it when filling out the WWSD section!

\begin{blocksection}
\begin{guide}
\textbf{Teaching Tips}
\begin{itemize}
    \item Boolean checks
        \begin{itemize}
        \item \lstinline{=} only works for integers/numbers
        \item \lstinline{eq?} is analogous to Python's \lstinline{is} (\textit{may} not work for numbers)
        \item \lstinline{eqv?} is a combination of Python's \lstinline{==} and \lstinline{is}
        \begin{itemize}
            \item For numbers, empty lists, booleans and symbols, it functions as \lstinline{==}
            \item For everything else (like pairs/lists), it functions as \lstinline{is}
        \end{itemize}
        \item \lstinline{equal?} is analogous to Python's \lstinline{==}
        \begin{itemize}
            \item It is also \lstinline{eqv?} with deep equality for lists
        \end{itemize}
        \item \lstinline{null?} checks if something is \lstinline{}
        \end{itemize}
\end{itemize}
\end{guide}
\end{blocksection}
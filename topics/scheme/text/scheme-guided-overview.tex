Scheme is a \textit{functional} language, as opposed to Python, which is an \textit{imperative} language. A Python program is comprised of \textit{statements} or ``instructions,'' each of which directs the computer to take some action. (An example of a statement would be something like \lstinline{x = 3} in Python. This does not evaluate to any value but just instructs Python to create a variable \lstinline{x} with the value 3.) In contrast, a Scheme program is composed solely of (often heavily nested) \textit{expressions}, each of which simply evaluates to a value. 

The three basic types of expressions in Scheme are atomics/primitive expressions, call expressions, and special forms.  

\subsection{Atomics}

Atomics are the simplest expressions. Some atomics, such as numbers and booleans, are called ``self-evaluating'' because they evaluate to themselves: 
\begin{itemize}
    \item \lstinline{123} $\rightarrow$ \lstinline{123}
    \item \lstinline{-3.14} $\rightarrow$ \lstinline{-3.14}
    \item \lstinline{#t} $\rightarrow$ \lstinline{#t ; booleans in scheme are #t and #f}
\end{itemize}

\textbf{Symbols} (variables) are also atomic expressions; they evaluate to the values to which they are bound. For example, the symbol \lstinline{+} evaluates to the addition \textbf{procedure} (function) \lstinline{#[+]}. 

\question Let's practice identifying atomic expressions in Scheme!

\begin{lstlisting}
    True or False: 3.14 is an atomic expression.
\end{lstlisting}
\begin{solution}[0.25in]
\texttt{True! Floats are atomic expressions.}
\end{solution}

\begin{lstlisting}
    True or False: pi is an atomic expression.
\end{lstlisting}
\begin{solution}[0.25in]
    \texttt{False. Pi in most cases isn't naturally defined within the programming language -- rather, it's a variable name. As we haven't defined pi in this case, Scheme doesn't know what to interpret pi as, so we get an Error if we try to evaluate this on its own.}
\end{solution}

\begin{lstlisting}
    True or False: - is an atomic expression.
\end{lstlisting}
\begin{solution}[0.25in]
    \texttt{True. - is an operator for subtraction.}
\end{solution}

\begin{lstlisting}
    True or False: ** is an atomic expression.
\end{lstlisting}
\begin{solution}[0.25in]
    \texttt{False. Scheme can only interpret the basic symbols of +, -, *, /. We'll have to define our own exponentiation function!}
\end{solution}

\begin{lstlisting}
    True or False: 'b' is an atomic expression.
\end{lstlisting}
\begin{solution}[0.25in]
    \texttt{True. 'b' is a character, which is an atomic data type!}
\end{solution}

\begin{lstlisting}
    True or False: "is this atomic?" is an atomic expression.
\end{lstlisting}
\begin{solution}[0.25in]
    \texttt{True. Even though a string is a list of characters, Scheme still treats them as an atomic. It's important to note that in Scheme's case, strings can only be denoted with ".}
\end{solution}

\subsection{Call Expressions}

A call expression is denoted with parentheses and is formed like so:
\vspace{0.5mm}
\begin{lstlisting}
(<operator> <operand0> <operand1> ... <operand>)
\end{lstlisting}
Each ``element'' of a call expression is an expression itself and is separated from its
neighbors by whitespace. All call expressions are evaluated in the same way:
\begin{enumerate}
\item Evaluate the operator, which will return a procedure.
\item Evaluate the operands.
\item Apply operator on operands.
\end{enumerate}
For example, to evaluate the call expression \lstinline{(+ (+ 1 2) 2)}, we first evaluate the operator \lstinline{+}, which returns the procedure \lstinline{#[+]}. Then we evaluate the first operand \lstinline{(+ 1 2)}, which returns \lstinline{3}. Then, we evaluate the last operand \lstinline{2}, receiving \lstinline{2}. Finally, we apply the \lstinline{#[+]} procedure to \lstinline{3} and \lstinline{2}, which returns \lstinline{5}. So this call expression evaluates to \lstinline{5}. 

Note that in order to add two numbers, we had to call a function. In Python, \lstinline{+} is a binary operator that can add two numbers without calling a function. Scheme has no such constructs, so even the most basic arithmetic requires you to call a function. The other math operators, including \lstinline{-} (both subtraction and negation), \lstinline{*}, \lstinline{/}, \lstinline{expt} (exponentiation), \lstinline{=}, \lstinline{<}, \lstinline{>}, \lstinline{<=}, and \lstinline{>=} function in the same way. 

\subsection{Special Forms}

Special forms \textit{look} just like call expressions but are distinct in two ways: 
\begin{enumerate}
    \item One of the following keywords appears in the operator slot: \lstinline{define}, \lstinline{if}, \lstinline{cond}, \lstinline{and}, \lstinline{or}, \lstinline{let}, \lstinline{begin}, \lstinline{lambda}, \lstinline{quote}, \lstinline{quasiquote}, \lstinline{unquote}, \lstinline{mu}, \lstinline{define-macro}, \lstinline{expect}, \lstinline{unquote-splicing}, \lstinline{delay}, \lstinline{cons-stream}, \lstinline{set!}
    \item They do not follow the evaluation rules for call expressions.
\end{enumerate}

Below, we will go through a few commonly seen special forms. 

\subsubsection{\lstinline{if} expression}
\begin{lstlisting}
(if <predicate> <true-expr> <false-expr>)
\end{lstlisting}

An \lstinline{if} expression is similar to a Python \lstinline{if} statement. First, evaluate \lstinline{<predicate>}. 
\begin{itemize}
    \item If \lstinline{<predicate>} is true, evaluate and return \lstinline{<true-expr>}.
    \item If \lstinline{<predicate>} is false, evaluate and return \lstinline{<false-expr>}.
\end{itemize}
Note that everything in Scheme is truthy (including \lstinline{0}) except for \lstinline{#f}. 

Also note that in Python, \lstinline{if} is a statement, whereas in Scheme, \lstinline{if} is an expression that evaluates to a value like any other expression would. In Scheme, you can then write something like this:
\begin{lstlisting}
scm> (+ 1 (if #t 9 99))
10
\end{lstlisting}

Other special forms are also expressions that evaluate to values. 
Therefore, when we say ``returns $x$,'' we mean ``the special form evaluates to $x$.''

\subsubsection{\lstinline{cond} expression}

\begin{lstlisting}
(cond 
    (<predicate1> <expr1>) 
    ... 
    (<predicateN> <exprN>) 
    (else <else-expr>))
\end{lstlisting}

A \lstinline{cond} expression is similar to a Python \lstinline{if}-\lstinline{elif}-\lstinline{else} statement. It is an alternative to using many nested \lstinline{if} expressions. 

\begin{itemize}
    \item Evaluate \lstinline{<predicate1>}. If it is true, evaluate and return \lstinline{<expr1>}.
    \item Otherwise, continue down the list by evaluating \lstinline{<predicate2>}. If it is true, evaluate and return \lstinline{<expr2>}.
    \item Continue in this fashion down the list until you hit a true predicate.
    \item If every predicate is false, return \lstinline{<else-expr>}. 
\end{itemize}

\subsubsection{\lstinline{and} expression}
\begin{lstlisting}
(and <expr1> ... <exprN>)
\end{lstlisting}
\lstinline{and} in Scheme works similarly to \lstinline{and} in Python. Evaluate the expressions in order and return the value of the first false expression. If all of the values are true, return the last value. If no operands are provided, return \lstinline{#t}.

\subsubsection{\lstinline{or} expression}
\begin{lstlisting}
(or <expr1> ... <exprN>)
\end{lstlisting}
\lstinline{or} in Scheme works similarly to \lstinline{or} in Python. Evaluate the expressions in order and return the value of the first true expression. If all of the values are false, return the last value. If no operands are provided, return \lstinline{#f}.

\subsubsection{\lstinline{define} expression}

\lstinline{define} does two things. It can define variables, similar to the Python \lstinline{=} assignment operator:
\begin{lstlisting}
(define <symbol> <expr>)
\end{lstlisting}
This will evaluate \lstinline{<expr>} and bind the resulting value to \lstinline{<symbol>} in the current frame. 

\lstinline{define} is also used to define procedures. 

\begin{lstlisting}
(define (<symbol> <op1> ... <opN>) 
    <body>)
    \end{lstlisting} 
This code will create a new procedure that takes in the formal parameters \lstinline{<op1> ... <opN>} and bind it to \lstinline{<symbol>} in the current frame. When that procedure is called, the \lstinline{<body>}, which may have multiple expressions, will be executed with the provided arguments bound to \lstinline{<op1> ... <opN>}. The value of the final expression of \lstinline{<body>} will be returned. 

With either version of \lstinline{define}, \lstinline{<symbol>} is returned. 

Dealing with the different types of \lstinline{define} can be tricky. Scheme differentiates between the two by whether the first operand is a symbol or a list:  
\begin{lstlisting}
(define (x) 1) ; like x = lambda: 1
(define x 1) ; like x = 1
\end{lstlisting}

\subsubsection{\lstinline{lambda} expressions}
\begin{lstlisting}
(lambda (<op1> ... <opN>) 
    <body>) 
\end{lstlisting}
Returns a new procedure that takes in the formal parameters \lstinline{<op1> ... <opN>}. When that procedure is called, the \lstinline{<body>}, which may have multiple expressions, will be executed with the provided arguments bound to \lstinline{<op1> ... <opN>}. The value of the final expression of \lstinline{<body>} will be returned. 

\subsubsection{\lstinline{begin} special form}
\begin{lstlisting}
(begin 
    <expr1>
    ... 
    <exprN>) 
\end{lstlisting}
Evaluates \lstinline{<expr1>}, \lstinline{<expr2>}, ..., \lstinline{<exprN>} in order in the current environment. Returns the value of \lstinline{<exprN>}. 

\subsubsection{\lstinline{let} special form}
\begin{lstlisting}
(let ((<symbol1> <expr1>) 
     ... 
     (<symbolN> <exprN>)) 
  <body>) 
\end{lstlisting}
Evaluates \lstinline{<expr1>}, ..., \lstinline{<exprN>} in the current environment. Then, creates a new frame as a child of the current frame and binds the values of \lstinline{<expr1>}, ..., \lstinline{<exprN>} to \lstinline{<symbol1>}, ..., \lstinline{<symbolN>}, respectively, in that new frame. Finally, Scheme evaluates the \lstinline{<body>}, which may have multiple expressions, in the new frame. The value of the final expression of \lstinline{<body>} is be returned. 

\subsubsection{\lstinline{quote} special form}
\begin{lstlisting}
(quote <expr>)
'<expr> ; shorthand syntax
\end{lstlisting}
Returns an expression that evaluates to \lstinline{<expr>} \textit{in its unevaluated form}. In other words, if you put \lstinline{'<expr>} into the Scheme interpreter, you should get \lstinline{<expr>} out \textit{exactly}. 


\subsubsection{Summary of special forms}
We have presented the main details of the most important special forms here, but this account is not comprehensive. Please see \url{https://cs61a.org/articles/scheme-spec/} for a fuller explanation of the Scheme language. 
\vspace{0.2in}
\begin{center}
\begin{tabular}{ |c|c| }
    \hline
    behavior & syntax \\
    \hline
    if/else & \texttt{(if <predicate> <true-expr> <false-expr>)}  \\
    \hline
    if/elif/else  
& \begin{lstlisting}
(cond 
    (<predicate1> <expr1>) 
    ... 
    (<predicateN> <exprN>) 
    (else <else-expr>))
\end{lstlisting} \\
    \hline
    and & \texttt{(and <expr1> ... <exprN>)} \\
    \hline
    or & \texttt{(or <expr1> ... <exprN>)} \\
    \hline
    variable assignment   & \texttt{(define <symbol> <expr>)} \\
    \hline
    function definition & 
\begin{lstlisting}
(define (<symbol> <op1> ... <opN>) 
    <body>)
\end{lstlisting}  \\
    \hline
    lambdas & 
\begin{lstlisting} 
(lambda (<op1> ... <opN>) 
    <body>) 
\end{lstlisting} \\
\hline
    evaluate many lines & 
\begin{lstlisting}
(begin 
    <expr1>
    ... 
    <exprN>) 
\end{lstlisting} \\
    \hline
    temporary environment & 
\begin{lstlisting} 
(let ((<symbol1> <expr1>) 
      ... 
      (<symbolN> <exprN>)) 
    <body>) 
\end{lstlisting}\\
    \hline
    quote & \texttt{(quote <expr>)} or \texttt{'<expr>}  \\
    \hline
\end{tabular}
\end{center}
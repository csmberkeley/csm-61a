\begin{blocksection}
\question Challenge: Write a function that returns true only if there exists a path from root to leaf that contains at least \lstinline$n$ instances of \lstinline$elem$ in a tree \lstinline$t$.

\begin{lstlisting}
def contains_n(elem, n, t):
    """
    >>> t1 = tree(1, [tree(1, [tree(2)])])
    >>> contains(1, 2, t1)
    True
    >>> contains(2, 2, t1)
    False
    >>> contains(2, 1, t1)
    True
    >>> t2 = tree(1, [tree(2), tree(1, [tree(1), tree(2)])])
    >>> contains(1, 3, t2)
    True
    >>> contains(2, 2, t2) # Not on a path
    False
    """
    if n == 0:

        return True

    elif ___________________________________________:

        return _____________________________________

    elif label(t) == elem:

        return _____________________________________

    else:

        return _____________________________________
\end{lstlisting}
\end{blocksection}

\begin{blocksection}
\begin{solution}
\begin{lstlisting}
    if n == 0:
        return True
    elif is_leaf(t):
        return n == 1 and label(t) == elem
    elif label(t) == elem:
        return True in [contains_n(elem, n - 1, b) for b in     
          branches(t)]
    else:
        return True in [contains_n(elem, n, b) for b in 
          branches(t)]
\end{lstlisting}
\end{solution}
\begin{blocksection}
    \begin{guide}
    \textbf{Teaching Tips}
    \begin{enumerate}
            \item Feel free to use the \texttt{any} Python built-in instead, which takes in a list of values and returns \texttt{True} if any of the values are truthy and \texttt{False} otherwise.
            \item Illustrate how \texttt{n} can be updated in our recursive calls in order to keep track of how many instances we've seen so far.
            \item The second base case is slightly tricky, so you're advised to start with the recursive calls first, which will make that base case make more sense.
    \end{enumerate}
    \end{guide}
\end{blocksection}

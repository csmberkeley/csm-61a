\vspace{2mm}
\begin{itemize}
\item The constructor constructs and returns a new instance of \lstinline{Tree}.
    \subitem \lstinline{t = Tree(1) # creates a Tree instance with label 1 and no branches.}
\item The \lstinline{label} and \lstinline{branches} are variables, and \lstinline{is_leaf()} is a method of the class.
    \subitem \lstinline{t.label # returns the label of the tree, which is the data stored inside the node of the "root," or, the tree we're measuring from.}
    \subitem \lstinline{t.branches # returns the branches of the tree, which is a list of sub-trees *directly* branching off of the tree, "t," in question.}
    \subitem \lstinline{t.is_leaf() # returns True if the tree is a leaf. For clarification, a tree is a leaf if it has no branches stemming from it.}
\item A tree object is mutable.
    \subitem To modify a \lstinline{Tree} object, simply reassign its attributes. For example, say we have a tree in which \lstinline{t.label = 1}. To reassign the tree/"root" node's label, we can say \lstinline{t.label = 2}.
    \subitem This means we can mutate values in the tree object instead of returning a mutated copy of the original tree. In other words, we can solve tree class problems non-destructively and destructively.
    \subitem By accessing the actual labels and branches of a tree, rather than accessing it through selector functions we used before such as label(t), branches(t), we can mutate a tree accordingly. Selector functions provide a "shield" of sorts that prevent the data inside of the tree from being mutated.
\end{itemize}
\vspace{2mm}
\textbf{The difference between the Tree class and the Tree abstract data type (using functions)}
\begin{itemize}
\item Using the constructor: Capital T for tree class and lower-case t for tree ADT
    \subitem \lstinline{t = Tree(1) # class} vs. \lstinline{t = tree(1) # adt functions}
\item hi \lstinline{label} and \lstinline{branches} are now attributes and, \lstinline{is_leaf()} is a method of the class instead of them all being functions.
    \subitem \lstinline{t.label vs. label(t)}
    \subitem \lstinline{t.branches vs. branches(t)}
    \subitem \lstinline{t.is_leaf() vs. is_leaf(t)}
\item A tree object is mutable while tree ADT is not mutable
    \subitem \lstinline{t.label = 2} vs. \lstinline{label(t) = 2 # this would error}
    \subitem This means we can mutate values in the tree object instead of making a new tree that we return. In other words, we can solve tree class problems non-destructively and destructively, but can only solve tree ADT problems non-destructively
\end{itemize}
Besides these differences, we use the same approach and ideas from ADT trees and apply them to Tree class including problem solving (base case, recursive calls, how to solve)  and respecting abstraction barrier. 

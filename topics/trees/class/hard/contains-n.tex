\begin{blocksection}
\question Write a function that returns true only if there exists a path from root to leaf that contains at least \lstinline$n$ instances of \lstinline$elem$ in a tree \lstinline$t$.

\begin{lstlisting}
def contains_n(elem, n, t):
    """
    >>> t1 = Tree(1, [Tree(1, [Tree(2)])])
    >>> contains_n(1, 2, t1)
    True
    >>> contains_n(2, 2, t1)
    False
    >>> contains_n(2, 1, t1)
    True
    >>> t2 = Tree(1, [Tree(2), Tree(1, [Tree(1), Tree(2)])])
    >>> contains_n(1, 3, t2)
    True
    >>> contains_n(2, 2, t2) # Not on a path
    False
    """
    if n == 0:
		
        return True
				
    elif ___________________________________________:
		
        return _____________________________________
				
    elif ___________________________________________:
		
        return _____________________________________
				
    else:
    
        return _____________________________________
\end{lstlisting}
\end{blocksection}
\begin{blocksection}
\begin{solution}
\begin{lstlisting}
    if n == 0:
        return True
    elif t.is_leaf():
        return n == 1 and t.label == elem
    elif t.label == elem:
        return True in [contains_n(elem, n - 1, b) for b in     
          t.branches]
    else:
        return True in [contains_n(elem, n, b) for b in 
          t.branches]
\end{lstlisting}
\textbf{Base cases}: The simplest case we have is when \lstinline{n == 0}, or when we want at least 0 instances of \lstinline{elem} in \lstinline{t}. In this case, we always return \lstinline{True}. The other simple case we consider is when the tree is only a leaf â€” there is nothing left to recurse on. In that case, we simply check to see that both \lstinline{n == 1} and that \lstinline{t.label == elem}, meaning that we have one element left to satisfy, and the leaf label satisfies the final element we are looking for. If we have more elements to search for (ie. n > 1), then we will not satisfy that many elements at the leaf node; conversely, if we have fewer (ie. \lstinline{n == 0}), then the case would already be covered by the first base case.

\textbf{Recursive cases}: If the current node isn't a leaf, then there's two different cases we should consider. Either the label of the current node is equal to \lstinline{elem} or the label is not equal to \lstinline{elem}. For the former, we would have to search for \lstinline{n} more \lstinline{elems} in each branch of \lstinline{t} and return \lstinline{True} if any of the branches contain \lstinline{n} elems. For the latter, we would have \lstinline{(n - 1)} elements remaining, so we would search for \lstinline{(n - 1)} more \lstinline{elems} in each branch of \lstinline{t} and return \lstinline{True} if any of the branches contain \lstinline{(n - 1)} \lstinline{elems}. Since there is not room to do a for loop, we can use a list comprehension to recursively call the function on each branch. Thus, our two list comprehension statements would be \lstinline{[contains_n(elem, n, b) for b in t.branches]} and \lstinline{[contains_n(elem, n - 1, b) for b in t.branches]}. To determine if any of the branches contain either \lstinline{n} elems or \lstinline{(n - 1)} elems, we can check if there's a \lstinline{True} element in the respective lists.

\end{solution}

\begin{guide}
    \textbf{Teaching Tips}
    \begin{itemize}
       \item Draw out the doctest Tree and walk through how you would delete path duplicates by hand. Then, ask your students, "how would we write this in code?"
       \item Recap tree functions "is\_leaf", "branches", and "label" if need be.
       \item Walk through the three main questions we ask when doing recursion: "what are our base cases?", "how can we reduce to our simplest case?", "how can we solve the smaller problem? (aka recursive leap of faith)"
    \end{itemize}
 \end{guide}

\end{blocksection}
